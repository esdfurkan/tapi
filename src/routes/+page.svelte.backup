<script lang="ts">
  import { invoke } from '@tauri-apps/api/core';
  import { downloadDir, join } from '@tauri-apps/api/path';
  import { open, save } from '@tauri-apps/plugin-dialog';
  import { open as openPath } from '@tauri-apps/plugin-shell';
  import { writeTextFile, writeFile } from '@tauri-apps/plugin-fs';
  import { listen } from '@tauri-apps/api/event';
  import { onMount, onDestroy } from 'svelte';
  import ModeCard from '$lib/components/ModeCard.svelte';
  import ProgressBar from '$lib/components/ProgressBar.svelte';
  import SettingsPanel from '$lib/components/SettingsPanel.svelte';
  import FolderSelectorModal from '$lib/components/FolderSelectorModal.svelte';
  import MangaLibraryModal from '$lib/components/MangaLibraryModal.svelte';
  // Dynamic import used instead for safety
  // import { isPermissionGranted, requestPermission, sendNotification } from '@tauri-apps/plugin-notification';

  let selectedMode = "cli";
  let folderPath = "";
  let status = "Ready";
  let progress = 0;
  let isTranslating = false;
  let logs: string[] = [];
  let showSettingsModal = false; // New state for modal toggle
  let showLibraryModal = false; // New state for library modal
  let showInfoModal = false; // Disclaimer info modal

  // Filtering
  let showFolderSelector = false;
  let showAndroidFolderPicker = false; // New modal specifically for choosing a TARGET ROOT on Android
  let includedPaths: string[] = [];  // If empty, process all. OR we pass this to backend.
  // Actually, backend 'processor' iterates recursively.
  // We should modify 'start_translation' to accept 'allowed_files' or similar?
  // Or simply: The user request implies filtering files/subfolders.
  // For now, let's keep it simple: If includedPaths is set, we only process those?
  // Given the backend structure (recursive walk), implementing a filter list is easy if we pass it.
  // But wait, processing a huge list of included files is heavy.
  // Better approach: If list is empty -> All. If not empty -> Only verify paths in list.
  
  // Since 'excluded' is usually smaller, maybe we track excluded?
  // But the UI selects 'Included'.
  
  // NOTE: For now, I will not modify backend translation logic to strictly obey this list because
  // sending thousands of file paths to backend command might be heavy? No, it's fine for local IPC.
  // I'll update backend if requested. But first UI.
  
  let unlistenLog: () => void;
  let unlistenProgress: () => void;
  let unlistenStats: () => void;
  
  // Settings
  let apiKey = "";
  let model = "default";
  let font = "wildwords";
  let targetLang = "en";
  let darkMode = false;
  
  // Advanced
  let textAlign = "auto";
  let strokeDisabled = false;
  let inpaintOnly = false;
  let minFontSize = 12;
  
  // API Endpoints
  let storageUrl = "https://api.toriitranslate.com/api/storage";
  let ocrUrl = "https://api.toriitranslate.com/api/ocr";
  let translateUrl = "https://api.toriitranslate.com/api/upload";

  // MangaDex Settings
  let mangadexUrl = "";
  let chapterNumber = 1;
  let mangadexFolderName = "Chapter_1";
  let seriesName = "";
  let selectedLanguage = "en";
  let useDataSaver = false; // Added Data Saver toggle
  let useDefaultFolder = true; 
  let isDownloading = false;
  let mangadexDownloadPath = "";

  const languages = [
      { code: "en", name: "English", flag: "üá¨üáß" },
      { code: "jp", name: "Japanese", flag: "üáØüáµ" },
      { code: "cn", name: "Chinese", flag: "üá®üá≥" },
      { code: "kr", name: "Korean", flag: "üá∞üá∑" },
      { code: "tr", name: "Turkish", flag: "üáπüá∑" },
      { code: "fr", name: "French", flag: "üá´üá∑" },
      { code: "es", name: "Spanish", flag: "üá™üá∏" },
      { code: "ru", name: "Russian", flag: "üá∑üá∫" },
      { code: "pt", name: "Portuguese", flag: "üáµüáπ" },
      { code: "it", name: "Italian", flag: "üáÆüáπ" },
      { code: "de", name: "German", flag: "üá©üá™" },
      { code: "id", name: "Indonesian", flag: "üáÆüá©" },
      { code: "vi", name: "Vietnamese", flag: "üáªüá≥" }
  ];

  // Auto-update folder name when chapter number changes
  $: mangadexFolderName = `Chapter_${chapterNumber}`;

  async function loadMangaDexHistory(path: string) {
    if (!path) return;
    try {
        const history: any = await invoke('load_mangadex_history', { targetDir: path });
        if (history) {
            logs = [...logs, "Loaded Mangadex settings from " + path];
            if (history.url) mangadexUrl = history.url;
            if (history.series_name) seriesName = history.series_name;
            if (history.language) selectedLanguage = history.language;
            if (history.last_chapter !== undefined) {
                chapterNumber = history.last_chapter + 1; // Suggest next chapter
                // Note: mangadexFolderName updates automatically via reactive statement $:
            }
        }
    } catch (e) {
        // No history found, or error reading it. Safe to ignore.
        // logs = [...logs, "No history found for this folder."];
    }
  }

  async function saveMangaDexHistory(path: string) {
      if (!path) return;
      try {
          await invoke('save_mangadex_history', {
              targetDir: path,
              url: mangadexUrl,
              chapter: parseFloat(chapterNumber.toString()),
              seriesName: seriesName,
              language: selectedLanguage
          });
          logs = [...logs, "Saved Mangadex settings."];
      } catch (e) {
          console.error("Failed to save history:", e);
      }
  }

  // Watch for directory changes to load history
  $: if (useDefaultFolder && folderPath) {
     loadMangaDexHistory(folderPath);
  }
  
  $: if (!useDefaultFolder && mangadexDownloadPath) {
     loadMangaDexHistory(mangadexDownloadPath);
  }

  async function selectMangaDexFolder() {
      status = "Opening folder picker...";

      // Android Workaround
      if (// @ts-ignore
        navigator.userAgent.toLowerCase().includes("android") || window.__TAURI_MOBILE__) {
         try {
            // Start at Downloads folder for better UX
            let base = "/storage/emulated/0/Download"; 
            try {
                base = await downloadDir();
            } catch (err) {}
            
            customSelectorRoot = base;
            isSelectingForMangadex = true;
            showAndroidFolderPicker = true;
            status = "Select a folder...";
            return;
         } catch (e) {
            alert("Error setting Android path: " + e);
            status = "Error: " + e;
            return;
         }
      }

      try {
        const selected = await open({
            directory: true,
            multiple: false,
            title: "Select Download Target Directory"
        });
        status = "Ready";
        if (selected) {
            mangadexDownloadPath = selected as string;
        }
      } catch (e) {
         status = "Error: " + e;
         alert("Error selecting folder: " + e);
      }
  }

  async function downloadManga() {
    if (!mangadexUrl) {
      alert("Please enter a MangaDex URL.");
      return;
    }

    let targetDir = useDefaultFolder ? folderPath : mangadexDownloadPath;
    
    if (useDefaultFolder && !folderPath) {
        alert("No default folder selected. Please select a folder in CLI mode first or uncheck 'Use Default Folder'.");
        return;
    }

    if (!useDefaultFolder && !mangadexDownloadPath) {
        alert("Please select a download directory first.");
        return;
    }

    isDownloading = true;
    status = "Downloading...";
    progress = 0;
    logs = [...logs, "Starting download from " + mangadexUrl];

    try {
        let result: string;
        
        // Check if URL is Mangadex or Other
        if (mangadexUrl.includes("mangadex.org")) {
            result = await invoke('download_mangadex_chapter', {
                url: mangadexUrl,
                folderName: mangadexFolderName,
                targetDir: targetDir,
                useDataSaver: useDataSaver,
                userAgent: navigator.userAgent,
                seriesName: seriesName
            });
        } else {
             // Use the wrapper for other sites (Pixiv, nHentai, Generic)
             // We pass 'null' for folderName to let backend decide based on title or ID
             // Or we can pass mangadexFolderName if we want to force it. 
             // Logic in backend: wrapper_download_url(app_handle, url, folder_name, target_dir, user_agent)
             // Note: In backend `wrapper_download_url` signature is (..., folder_name: Option<String>, ...)
             // But my recent backend edit might have specific args. Let's check backend signature.
             // Backend: wrapper_download_url(app_handle, url, folder_name, target_dir, user_agent)
             
             result = await invoke('wrapper_download_url', {
                url: mangadexUrl,
                folderName: mangadexFolderName, // We can reuse this or pass null
                targetDir: targetDir,
                userAgent: navigator.userAgent
             });
        }
        
        // Save history on success
        await saveMangaDexHistory(targetDir);

        logs = [...logs, result];
        status = "Download Complete!";
        
        // Auto-increment chapter for next download (only makes sense for mangadex really, but harmless)
        chapterNumber = parseFloat((chapterNumber + 1).toFixed(1));
        
        await notifyCompletion("Download Completed", "Download finished successfully!");
    } catch (e: any) {
        status = "Error: " + e;
        logs = [...logs, "Download Error: " + e];
        await notifyCompletion("Download Failed", "Failed to download chapter.");
        alert("Download Failed: " + e); // Keep alert for error
    } finally {
        isDownloading = false;
    }
  }

  $: if (typeof document !== 'undefined') {
    document.documentElement.classList.toggle('dark', darkMode);
  }



  // Stats Overlay
  let showStats = false;
  let systemStats = {
      cpu_usage: 0,
      ram_used: 0,
      ram_total: 0,
      ram_percentage: 0
  };
  let totalCredits = 0;

  function toggleStats(e: KeyboardEvent) {
      if (e.key === "Shift" && e.location === 2) { // Location 2 is Right Shift
          showStats = !showStats;
      }
  }

  function formatBytes(bytes: number) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB']; // GB is enough for RAM
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  async function notifyCompletion(title: string, body: string) {
      // Play sound - Rare and Random (approx 15% chance)
      try {
        if (Math.random() < 0.15) {
            const audio = new Audio('/audio/notification.opus');
            audio.play().catch(e => {
                console.warn("Audio play failed:", e);
               // logs = [...logs, "Audio Error: " + e]; // Optional debug
            });
        }
      } catch (e) {
          console.warn("Audio init failed:", e);
      }

      // Send System Notification
      try {
          const { isPermissionGranted, requestPermission, sendNotification } = await import('@tauri-apps/plugin-notification');

          let permissionGranted = await isPermissionGranted();
          if (!permissionGranted) {
              const permission = await requestPermission();
              permissionGranted = permission === 'granted';
          }
          
          if (permissionGranted) {
              sendNotification({ title, body });
          }
      } catch (e) {
          console.error("Notification failed:", e);
      }
  }

  onMount(async () => {
    window.addEventListener('keydown', toggleStats);

    unlistenStats = await listen('system-stats', (event: any) => {
        systemStats = event.payload;
        // Credits are not in the payload, but we can re-read profile or just rely on start load?
        // Actually, we should probably include credits in the stats or poll profile settings.
        // For now, let's just update credits when we load settings or start translation.
        // Better: The periodic saving of profile updates the file, but frontend doesn't know unless we reload.
        // We can just add credits to the event payload if we modify monitor.rs to read profile?
        // No, monitor is minimal. Let's just create a separate interval to fetch settings to update credits for now?
        // Or assume the backend emits credits update separately?
    });

    // Simple poller for credits update (every 5 seconds)
    const creditInterval = setInterval(async () => {
         if (showStats) {
             try {
                const p: any = await invoke('load_settings');
                if (p && p.total_credits_used !== undefined) {
                    totalCredits = p.total_credits_used;
                }
             } catch {}
         }
    }, 5000);

    unlistenLog = await listen('translation-log', (event) => {
      // Keep only last 1000 logs to prevent memory crash
      if (logs.length > 1000) {
        logs = logs.slice(-900); // Remove oldest
      }
      logs = [...logs, event.payload as string];
      // Auto-scroll logic could go here if we bound the container
    });

    unlistenProgress = await listen('translation-progress', (event: any) => {
      const p = event.payload;
      if (p) {
        progress = p.percentage;
        status = p.message;
      }
    });

    try {
      const profile: any = await invoke('load_settings');
      if (profile) {
        apiKey = profile.api_key || "";
        model = profile.model || "default";
        font = profile.font || "wildwords";
        targetLang = profile.language || "en";
        totalCredits = profile.total_credits_used || 0;
        
        // Load API endpoints
        storageUrl = profile.storage_url || "https://api.toriitranslate.com/api/storage";
        ocrUrl = profile.ocr_url || "https://api.toriitranslate.com/api/ocr";
        translateUrl = profile.translate_url || "https://api.toriitranslate.com/api/upload";
        
        if (profile.theme === "dark") {
          darkMode = true;
        }
      }
    } catch (e) {
      console.error("Failed to load settings", e);
    }
  });

  onDestroy(() => {
    window.removeEventListener('keydown', toggleStats);
    if (unlistenLog) unlistenLog();
    if (unlistenProgress) unlistenProgress();
    if (unlistenStats) unlistenStats();
  });

  async function copyLogs() {
    try {
      await navigator.clipboard.writeText(logs.join('\n'));
      alert("Logs copied to clipboard!");
    } catch (e) {
      alert("Failed to copy logs: " + e);
    }
  }

  async function saveLogs() {
    try {
      const path = await save({
        filters: [{
          name: 'Log File',
          extensions: ['txt', 'log']
        }]
      });
      if (path) {
        await writeTextFile(path, logs.join('\n'));
        alert("Logs saved!");
      }
    } catch (e) {
      alert("Failed to save logs: " + e);
    }
  }

  // Custom Mobile Select Logic
  // We reuse the existing FolderSelectorModal but point it to root on Main Logic
  let customSelectorRoot = "";
  let isSelectingForMangadex = false;

  function openCustomFolderSelector(startInfo: string, isMangadex: boolean = false) {
      customSelectorRoot = startInfo;
      isSelectingForMangadex = isMangadex;
      showFolderSelector = true; // reusing existing boolean, but wait...
      // existing 'showFolderSelector' is used for "Select specific subfolders/files" logic (Modal)
      // We can reuse that component?
      // Let's check FolderSelectorModal usage in template.
      // It normally takes a rootPath. If we set rootPath to 'customSelectorRoot', it might work for BROWSING too if we tweak it to resolve "This is the folder I want".
      
      // Actually, looking at FolderSelectorModal, it allows selecting FILES/Folders to process.
      // We want to SELECT A TARGET ROOT.
      // Maybe we can adapt it or add a "Select Current Folder" button inside it?
      // Or just create a separate simple instance for this.
  }

  // Replacing the previous selectFolder function
  async function selectFolder() {
    status = "Opening folder picker...";
    
    // Android Workaround: Use Custom Modal
    if (// @ts-ignore
        navigator.userAgent.toLowerCase().includes("android") || window.__TAURI_MOBILE__) {
          try {
             // Start at Downloads folder for better UX (User Request)
             let base = "/storage/emulated/0/Download";
             try {
                base = await downloadDir();
             } catch(e) {
                 // Fallback to manual if API fails
                 base = "/storage/emulated/0/Download";
             }
             
             customSelectorRoot = base;
             isSelectingForMangadex = false;
             showAndroidFolderPicker = true;
             status = "Select a folder...";
             return;
          } catch(e) {
             alert("Could not access storage: " + e);
          }
          return;
    }

    try {
      const selected = await open({
        directory: true,
        multiple: false,
      });
      status = "Ready"; // Reset status
      if (selected) {
        folderPath = selected as string;
        // Reset inclusion list when folder changes
        includedPaths = [];
      }
    } catch (e) {
      status = "Error: " + e;
      alert("Error opening folder picker: " + e);
      console.error(e);
    }
  }

  function openFolderSelector() {
      if (!folderPath) {
          alert("Please select a folder first.");
          return;
      }
      showFolderSelector = true;
  }

  function handleFolderSelection(paths: string[]) {
      includedPaths = paths;
      alert(`Selected ${paths.length} items to translate.`);
      showFolderSelector = false;
  }

  async function openOutputFolder() {
    if (!folderPath) return;
    const subDir = selectedMode === 'archive' ? 'archive_outputs' : 'translated';
    // We can try to open the specific output folder, or just the parent folder if that fails
    // Since we don't have a "join" function in frontend easily, we assume standard separator or let shell handle it
    // But safer to just open the parent folderPath which we know exists
    try {
      await openPath(folderPath); 
    } catch (e) {
      alert("Failed to open folder: " + e);
    }
  }

  async function startTranslation() {
    if (!folderPath) {
      alert("Please select a folder first.");
      return;
    }
    if (!apiKey) {
      alert("Please enter API Key in settings.");
      return;
    }

    isTranslating = true;
    status = "Starting...";
    progress = 0;
    logs = ["Starting translation..."];

    try {
      await invoke('start_translation', { 
        folderPath, 
        model, 
        mode: selectedMode,
        targetLang,
        font,
        textAlign,
        strokeDisabled,
        inpaintOnly,
        minFontSize
      });
      status = "Completed!";
      logs = [...logs, "Translation Completed Successfully!"];
      progress = 100;
      await notifyCompletion("Task Completed", "Translation finished successfully!");
    } catch (e) {
      status = "Error: " + e;
      logs = [...logs, "Error: " + e];
      await notifyCompletion("Task Failed", "An error occurred during translation.");
    } finally {
      isTranslating = false;
    }
  }
</script>

<main class="min-h-screen bg-gray-100 dark:bg-gray-900 p-8 transition-colors relative">
  <FolderSelectorModal 
    bind:isOpen={showFolderSelector}
    rootPath={folderPath}
    onConfirm={handleFolderSelection}
    onCancel={() => showFolderSelector = false}
  />
  
  {#if showStats}
    <div class="fixed top-4 right-4 z-50 bg-black/80 text-white p-4 rounded shadow-lg backdrop-blur-sm text-xs font-mono border border-gray-700 w-64 pointer-events-none select-none">
        <h3 class="font-bold text-green-400 mb-2 border-b border-gray-600 pb-1">SYSTEM MONITOR</h3>
        <div class="grid grid-cols-2 gap-y-1">
            <span class="text-gray-400">Total Credits:</span>
            <span class="text-right text-yellow-300">{totalCredits}</span>
            
            <span class="text-gray-400">CPU Usage:</span>
            <span class="text-right">{systemStats.cpu_usage.toFixed(1)}%</span>
            
            <span class="text-gray-400">RAM Usage:</span>
            <span class="text-right">{formatBytes(systemStats.ram_used)}</span>
            
            <span class="text-gray-400">RAM Total:</span>
            <span class="text-right">{formatBytes(systemStats.ram_total)}</span>

            <span class="text-gray-400">RAM Load:</span>
            <span class="text-right">
                <div class="w-full bg-gray-700 h-2 mt-1 rounded-full overflow-hidden">
                    <div class="bg-blue-500 h-full" style="width: {systemStats.ram_percentage}%"></div>
                </div>
            </span>
        </div>
        <div class="mt-2 text-gray-500 text-[10px] text-center">
            Updated every 1.5s
        </div>
    </div>
  {/if}

  <div class="max-w-4xl mx-auto">
    <header class="mb-8">
      <h1 class="text-3xl font-bold text-gray-900 dark:text-white">TAPI Translation Tool</h1>
      <p class="text-gray-600 dark:text-gray-400">Select a mode and start translating.</p>
    </header>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
      <ModeCard 
        title="CLI / Folder" 
        description="Translate a local folder of images." 
        icon="üìÅ" 
        selected={selectedMode === 'cli'}
        onClick={() => selectedMode = 'cli'}
      />
      <ModeCard 
        title="Archive" 
        description="Translate ZIP/CBZ/PDF files." 
        icon="üì¶" 
        selected={selectedMode === 'archive'}
        onClick={() => selectedMode = 'archive'}
      />
      <ModeCard 
        title="MangaDex" 
        description="Download and translate from MangaDex." 
        icon="üåê" 
        selected={selectedMode === 'mangadex'}
        onClick={() => selectedMode = 'mangadex'}
      />
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <!-- Main Content -->
      <div class="lg:col-span-2 space-y-6">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm transition-colors">
          <h2 class="text-xl font-semibold mb-4 dark:text-white">
            {selectedMode === 'cli' ? 'Folder Translation' : 
             selectedMode === 'archive' ? 'Archive Translation' : 'MangaDex Downloader'}
          </h2>
          
          {#if selectedMode === 'cli' || selectedMode === 'archive'}
            <div class="space-y-4">
              <div class="flex gap-2">
                <input 
                  type="text" 
                  bind:value={folderPath} 
                  placeholder={selectedMode === 'archive' ? "/path/to/folder/with/archives" : "/path/to/images"}
                  class="flex-1 p-2 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  readonly
                />
                <button 
                  on:click={selectFolder}
                  class="bg-gray-200 dark:bg-gray-600 dark:text-white px-4 py-2 rounded hover:bg-gray-300 dark:hover:bg-gray-500"
                >
                  Browse
                </button>
              </div>

              {#if folderPath && selectedMode === 'cli'}
                 <div class="flex justify-start">
                    <button 
                        on:click={openFolderSelector}
                        class="text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 flex items-center gap-1"
                    >
                        <span>üå≥</span> Select specific subfolders/files
                    </button>
                    {#if includedPaths.length > 0}
                        <span class="ml-2 text-xs text-green-600 dark:text-green-400 self-center">({includedPaths.length} items selected)</span>
                    {/if}
                 </div>
              {/if}

              {#if folderPath}
                <p class="text-xs text-gray-500 dark:text-gray-400 ml-1">
                  Output: {folderPath}/{selectedMode === 'archive' ? 'archive_outputs' : 'translated'}
                </p>
              {/if}

              {#if isTranslating}
                <ProgressBar {progress} {status} />
              {:else}
                <button 
                  on:click={startTranslation}
                  class="w-full bg-blue-600 text-white py-3 rounded-lg font-medium hover:bg-blue-700 transition-colors"
                >
                  Start Translation
                </button>
                {#if status !== "Ready" || logs.length > 0}
                  <div class="mt-4 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 p-3">
                    <div class="flex justify-between items-center mb-2">
                      <span class="text-sm font-semibold text-gray-700 dark:text-gray-200">Status Log</span>
                      <div class="flex gap-2">
                        {#if status === "Completed!"}
                          <button on:click={openOutputFolder} class="text-xs bg-green-100 text-green-800 border border-green-200 px-2 py-1 rounded hover:bg-green-200">Open Folder</button>
                        {/if}
                        <button on:click={copyLogs} class="text-xs bg-white dark:bg-gray-600 dark:text-white border dark:border-gray-500 px-2 py-1 rounded hover:bg-gray-100 dark:hover:bg-gray-500">Copy</button>
                        <button on:click={saveLogs} class="text-xs bg-white dark:bg-gray-600 dark:text-white border dark:border-gray-500 px-2 py-1 rounded hover:bg-gray-100 dark:hover:bg-gray-500">Save</button>
                      </div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 dark:text-gray-300 border dark:border-gray-600 rounded p-2 h-32 overflow-y-auto text-xs font-mono whitespace-pre-wrap">
                      {#each logs as log}
                        <div>{log}</div>
                      {/each}
                      {#if status !== "Ready" && !logs.includes(status) && !logs.some(l => l.includes(status))}
                         <div class="font-bold mt-1">{status}</div>
                      {/if}
                    </div>
                  </div>
                {/if}
              {/if}
            </div>
          {:else if selectedMode === 'mangadex'}
            <div class="space-y-4">
               <div class="flex flex-col gap-2">
                  <label class="flex flex-col gap-2">
                      <span class="text-sm font-medium dark:text-gray-300">Series Name</span>
                      <div class="flex gap-2">
                          <input 
                            type="text" 
                            bind:value={seriesName} 
                            placeholder="e.g. One Piece"
                            class="flex-1 p-2 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                          />
                          <button 
                            on:click={() => showLibraryModal = true}
                            class="px-3 py-2 bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-200 border border-yellow-200 dark:border-yellow-800 rounded hover:bg-yellow-200 dark:hover:bg-yellow-900/50 flex items-center gap-1"
                            title="Open Library"
                          >
                             üìö Library
                          </button>
                      </div>
                  </label>
               </div>

               <div class="flex flex-col gap-2 relative">
                  <label class="flex flex-col gap-2">
                      <div class="flex items-center gap-2">
                          <span class="text-sm font-medium dark:text-gray-300">URL (MangaDex / Pixiv / nHentai / Any)</span>
                          <button 
                            on:click={() => showInfoModal = true} 
                            class="text-gray-500 hover:text-blue-500 dark:text-gray-400 dark:hover:text-blue-400 rounded-full border border-current w-4 h-4 flex items-center justify-center text-[10px]" 
                            title="Examples & Info"
                          >
                            i
                          </button>
                      </div>
                      <div class="flex gap-2">
                          <input 
                            type="text" 
                            bind:value={mangadexUrl} 
                            placeholder="https://mangadex.org/chapter/..."
                            class="flex-1 p-2 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                          />
                          <button 
                            on:click={async () => {
                                try {
                                    const text = await navigator.clipboard.readText();
                                    if (text) mangadexUrl = text;
                                } catch (e) {
                                    console.error("Paste failed", e);
                                    alert("Could not access clipboard. Please paste manually.");
                                }
                            }}
                            class="px-3 py-2 bg-gray-200 dark:bg-gray-600 rounded hover:bg-gray-300 dark:hover:bg-gray-500"
                            title="Paste from Clipboard"
                          >
                             üìã
                          </button>
                      </div>
                  </label>
               </div>

               <div class="flex flex-col gap-2">
                   <label class="flex flex-col gap-2">
                       <span class="text-sm font-medium dark:text-gray-300">Language</span>
                       <select bind:value={selectedLanguage} class="p-2 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                           {#each languages as lang}
                               <option value={lang.code}>{lang.flag} {lang.name}</option>
                           {/each}
                       </select>
                   </label>
               </div>

               <div class="flex gap-4">
                 <div class="w-1/3 flex flex-col gap-2">
                    <label class="flex flex-col gap-2">
                        <span class="text-sm font-medium dark:text-gray-300">Chapter No</span>
                        <div class="flex items-center gap-1">
                            <button 
                                on:click={() => chapterNumber = Math.max(0, parseFloat((chapterNumber - 1).toFixed(1)))}
                                class="w-8 h-10 bg-gray-200 dark:bg-gray-600 rounded flex items-center justify-center hover:bg-gray-300 dark:hover:bg-gray-500 font-bold text-lg"
                            >-</button>
                            <input 
                              type="number" 
                              bind:value={chapterNumber} 
                              min="0"
                              step="0.1"
                              class="flex-1 p-2 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-center"
                            />
                            <button 
                                on:click={() => chapterNumber = parseFloat((chapterNumber + 1).toFixed(1))}
                                class="w-8 h-10 bg-gray-200 dark:bg-gray-600 rounded flex items-center justify-center hover:bg-gray-300 dark:hover:bg-gray-500 font-bold text-lg"
                            >+</button>
                        </div>
                    </label>
                 </div>
                 <div class="w-2/3 flex flex-col gap-2">
                    <label class="flex flex-col gap-2">
                        <span class="text-sm font-medium dark:text-gray-300">Folder Name (Preview)</span>
                        <input 
                          type="text" 
                          bind:value={mangadexFolderName} 
                          class="p-2 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white font-mono"
                        />
                    </label>
                 </div>
               </div>

               <div class="flex items-center gap-2">
                  <input type="checkbox" id="useDefaultFolder" bind:checked={useDefaultFolder} class="w-4 h-4" />
                  <label for="useDefaultFolder" class="text-sm text-gray-700 dark:text-gray-300">Use default 'Folder Translation' path</label>
               </div>

               <div class="flex items-center gap-2">
                  <input type="checkbox" id="useDataSaver" bind:checked={useDataSaver} class="w-4 h-4" />
                  <label for="useDataSaver" class="text-sm text-gray-700 dark:text-gray-300">Use Data Saver (Lower Quality)</label>
               </div>
               
               {#if !useDefaultFolder}
                  <div class="flex gap-2">
                        <input 
                        type="text" 
                        bind:value={mangadexDownloadPath} 
                        placeholder="/path/to/download"
                        class="flex-1 p-2 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        readonly
                        />
                        <button 
                        on:click={selectMangaDexFolder}
                        class="bg-gray-200 dark:bg-gray-600 dark:text-white px-4 py-2 rounded hover:bg-gray-300 dark:hover:bg-gray-500"
                        >
                        Browse
                        </button>
                    </div>
                 <p class="text-xs text-gray-500 dark:text-gray-400">Save to: {mangadexDownloadPath ? mangadexDownloadPath + '/' + mangadexFolderName : 'Select a folder first'}</p>
               {:else if folderPath}
                  <p class="text-xs text-gray-500 dark:text-gray-400">Save to: {folderPath}/{mangadexFolderName}</p>
               {:else}
                  <p class="text-xs text-red-500">Warning: No default folder selected. Go to 'Folder Translation' to select one, or uncheck the box above.</p>
               {/if}

               {#if isDownloading}
                  <ProgressBar progress={progress} status={status} />
               {:else}
                  <button 
                    on:click={downloadManga}
                    class="w-full bg-green-600 text-white py-3 rounded-lg font-medium hover:bg-green-700 transition-colors"
                  >
                    Download Chapter
                  </button>
               {/if}

               <!-- Log Section for Downloader -->
               {#if logs.length > 0 && selectedMode === 'mangadex'}
                  <div class="mt-4 border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 p-3">
                     <span class="text-sm font-semibold text-gray-700 dark:text-gray-200 mb-2 block">Logs</span>
                     <div class="bg-white dark:bg-gray-800 dark:text-gray-300 border dark:border-gray-600 rounded p-2 h-32 overflow-y-auto text-xs font-mono whitespace-pre-wrap">
                        {#each logs as log}
                           <div>{log}</div>
                        {/each}
                     </div>
                  </div>
               {/if}
            </div>
          {:else}
            <p class="text-gray-500 italic">This mode is not yet fully implemented in the frontend demo.</p>
          {/if}
        </div>
      </div>

      <!-- Sidebar & Settings Toggle -->
      <div class="space-y-6 lg:col-span-1">
        <!-- Desktop: Always Visible Settings -->
        <div class="hidden lg:block">
           <SettingsPanel 
              bind:apiKey 
              bind:model 
              bind:font
              bind:targetLang 
              bind:darkMode
              bind:textAlign
              bind:strokeDisabled
              bind:inpaintOnly
              bind:minFontSize
              bind:storageUrl
              bind:ocrUrl
              bind:translateUrl
            />
        </div>

        <!-- Mobile/Small Screens: Toggle Button for Settings -->
        <div class="lg:hidden">
             <button 
                on:click={() => showSettingsModal = true}
                class="w-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 py-3 rounded-lg font-medium flex items-center justify-center gap-2"
             >
                <span>‚öôÔ∏è</span> Open Settings
             </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal for Small Screens (or if we want to switch to modal fully later) -->
  {#if showSettingsModal}
      <div class="fixed inset-0 bg-black/50 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
         <div class="bg-white dark:bg-gray-900 rounded-xl shadow-2xl w-full max-w-md max-h-[90vh] overflow-y-auto relative">
             <button 
               on:click={() => showSettingsModal = false}
               class="absolute top-4 right-4 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 z-10 p-2"
             >
               ‚úï
             </button>
             <div class="p-2">
                 <SettingsPanel 
                    bind:apiKey 
                    bind:model 
                    bind:font
                    bind:targetLang 
                    bind:darkMode
                    bind:textAlign
                    bind:strokeDisabled
                    bind:inpaintOnly
                    bind:minFontSize
                    bind:storageUrl
                    bind:ocrUrl
                    bind:translateUrl
                  />
             </div>
             <div class="p-4 border-t border-gray-200 dark:border-gray-700 mt-2">
                 <button 
                   on:click={() => showSettingsModal = false}
                   class="w-full bg-blue-600 text-white py-2 rounded-lg font-medium"
                 >
                   Done
                 </button>
             </div>
         </div>
      </div>
  {/if}

<MangaLibraryModal 
    show={showLibraryModal} 
    targetDir={useDefaultFolder ? folderPath : mangadexDownloadPath}
    onSelect={(name) => seriesName = name}
    onClose={() => showLibraryModal = false}
/>

{#if showAndroidFolderPicker}
    <FolderSelectorModal 
        rootPath={customSelectorRoot} 
        isOpen={showAndroidFolderPicker}
        onConfirm={(paths) => {
             // Logic for Android Folder Picker
             // We interpret the first selected item as the target.
             if (paths.length > 0) {
                 const chosen = paths[0]; // Take the first checked item
                 if (isSelectingForMangadex) {
                     mangadexDownloadPath = chosen;
                 } else {
                     folderPath = chosen;
                     includedPaths = [];
                 }
            } else {
                 // Fallback to root if nothing selected
                 if (isSelectingForMangadex) {
                     mangadexDownloadPath = customSelectorRoot;
                 } else {
                     folderPath = customSelectorRoot;
                 }
            }
            showAndroidFolderPicker = false;
            status = "Ready";
        }}
        onCancel={() => {
            showAndroidFolderPicker = false;
            status = "Cancelled selection";
        }}
    />
{/if}

{#if showInfoModal}
    <div class="fixed inset-0 bg-black/50 z-50 flex items-center justify-center backdrop-blur-sm p-4">
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-lg w-full overflow-hidden border border-gray-100 dark:border-gray-700">
             <div class="px-6 py-4 border-b border-gray-100 dark:border-gray-700 flex justify-between items-center bg-gray-50 dark:bg-gray-800/50">
                <h3 class="font-bold text-lg dark:text-white">Supported Sites & Disclaimer</h3>
                <button on:click={() => showInfoModal = false} class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300">‚úï</button>
             </div>
             
             <div class="p-6 space-y-4 max-h-[70vh] overflow-y-auto">
                 <div class="bg-red-50 dark:bg-red-900/20 border border-red-100 dark:border-red-800 rounded-lg p-3 text-sm text-red-800 dark:text-red-200">
                    <strong>Disclaimer:</strong> This software is provided for educational and personal archiving purposes only. 
                    The developers assume no liability for the content downloaded or how it is used. 
                    Please respect copyright laws and the terms of service of the respective websites.
                 </div>

                 <div class="space-y-2">
                    <h4 class="font-semibold dark:text-white">Supported Platforms</h4>
                    <ul class="list-disc list-inside text-sm space-y-1 text-gray-700 dark:text-gray-300">
                        <li><span class="font-medium text-orange-600">MangaDex</span>: Full Chapter & Data Saver support.</li>
                        <li><span class="font-medium text-blue-500">Pixiv</span>: Auto-fetches "Original" quality artworks (bypasses 1200px limit).</li>
                        <li><span class="font-medium text-pink-500">nHentai</span>: Auto-resolves Gallery IDs and bypasses subdomain protections.</li>
                        <li><span class="font-medium text-green-600">Generic</span>: Scrapes & downloads .jpg/.png/.webp images from ANY standard webpage.</li>
                    </ul>
                 </div>
                 
                 <div class="bg-blue-50 dark:bg-blue-900/20 rounded-lg p-3 text-xs text-blue-800 dark:text-blue-200">
                    <strong>Auto-Protection Bypass:</strong> The downloader uses your local browser cookies/headers (User-Agent) to bypass Cloudflare and DDOS-Guard protections automatically.
                 </div>
             </div>

             <div class="p-4 border-t border-gray-100 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50 text-right">
                  <button on:click={() => showInfoModal = false} class="bg-gray-800 text-white px-4 py-2 rounded-lg text-sm hover:bg-gray-700">Understood</button>
             </div>
        </div>
    </div>
  {/if}

</main>
